---
layout: page
title: What to read
---

A curated list of books for programmers who want to build things that endure. Click any title below to read commentary.

## Index

- [Douglas Hofstadter — *Gödel, Escher, Bach*](#geb)



<details>
<summary><strong>Most software today is built to be forgotten</strong></summary>
<div>

<p>Written in haste, layered with abstractions, then discarded with the next trend.
We build like amnesiacs: few know how the systems beneath them truly work.
Fewer care.
The result is not progress, but erosion masked as innovation.
Like a civilization building towers higher and higher while forgetting how to quarry stone.</p>

<p>Jonathan Blow warned us of this trajectory:
a slow technological decline driven not by catastrophe, but by accumulated ignorance.
As layers pile on, foundations are lost.
One day, the lights will go out—not because no one tried to keep them on, but because no one remembered how.</p>

<p>There is another path.</p>

<p>We can choose to treat software not as a disposable product, but as a form of cultural expression.
A craft whose goal is not speed or scale, but clarity, permanence, and meaning.</p>

<p>This is the path of Emacs, Vim, Unix, and many other libraries and systems built and maintained in C, that old, unsafe, language.
The very language used to build and maintain most of the internet infrastructure.
Systems some call “legacy” which are indeed civilizational infrastructure.
Yeah, JavaScript is just a thin wrapper over decades of C/C++.</p>

<p>They have not survived in spite of their age.
They have survived because they were built to endure.</p>

<p>To walk this path requires more than technical competence.
It requires erudition.</p>

<p>Erudition is not mere knowledge—it is the discipline of memory.
It is the refusal to discard what came before simply because it is old.
It is what separates the craftsman from the technician.
The former builds tools; the latter uses them.</p>

<p>This is not a call for nostalgia.
It is a call for depth.</p>

<p>Edsger Dijkstra argued that software should be beautiful—that clarity and elegance are moral virtues in code.
Richard Stallman, despite his politics, glimpsed something similar: software, if well written and liberated from arbitrary dependencies, becomes free from its creators.
It becomes self-sufficient, a thing that exists on its own terms.</p>

<p>To write such software is not merely engineering.
It is a form of authorship.</p>

<p>And yet, why bother?</p>

<p>Economics can’t fully explain open source.
Eric Raymond got close—yes, incentives matter—but the real motivation is harder to measure.
It’s not just reputation or signaling.
It’s something older, deeper.
The pride of the artisan.
The drive to leave something behind.
The desire to see one's soul reflected in a functioning machine.</p>

<p>We don't need more developers.
We need stewards of tradition.
Programmers who see themselves as participants in a conversation older than their tools.
Programmers who understand that code is not just meant to work, but to last.</p>

<h2>On Education and the Cult of Utility</h2>

<p>Our institutions are not preparing the next generation to build what endures.</p>

<p>Schools are increasingly pressured into “project-based,” “real-world,” “hands-on” pedagogies—buzzwords that too often mean building whatever solves the most immediate problem, then moving on.
This is the educational branch of the same Silicon Valley rot: fail fast, fail often, ship it, forget it.</p>

<p>At the same time, theory-driven programs—those that ground students in algorithms, computation, and systems—are dismissed as outmoded.
Why study SMTP when you can deploy a serverless app in five minutes?
Why implement a shell when you can call one?
Why understand when you can use?</p>

<p>This is a catastrophe disguised as relevance.</p>

<p>Real-world problems aren’t just the ones we face now—they are the ones we’ve already solved.
The wheel, once invented, is worth studying.
But we rarely ask students to reimplement anything that matters.
How many have written a shell?
A CLI email client?
A toy compiler?
A browser?
An operating system?
These are exercises not in nostalgia, but in transmission—how to pass down the thinking behind software that actually lasts.</p>

<p>Instead, we hand students tools as if they were gifts from God.</p>

<p>But God does not maintain software. That’s up to us.</p>

<h2>On AI and the Seduction of Vibe Coding</h2>

<p>The recent obsession with large language models has amplified the very disease we aim to treat.
It is now fashionable to "vibe code"—to prompt a machine, skim the output, and paste until it runs.
It feels like programming.
It looks like productivity.
But it is neither.</p>

<p>Vibe coding is just the latest form of disposable software creation.
It encourages the illusion of mastery while hollowing out the discipline itself.
You are not becoming a better developer by prompting until it compiles.
You are simply becoming a more efficient operator of a glorified autocomplete engine.</p>

<p>There is nothing wrong with using LLMs—when used with intentionality and craft.
For the erudite programmer, these models are like sharpened chef’s knives: tools to accelerate judgment, precision, and depth.
But in unskilled hands, they do not produce better software.
They produce more software.
Worse software.
Cheap, flimsy, mass-produced code—the Chinese plastic of the digital world.</p>

<p>And worst of all:
we are deceiving ourselves.
We confuse activity with learning.
We conflate output with experience.
We mistake convenience for growth.</p>

<p>This is why we read.
Not to memorize syntax, but to train our taste.
Not to chase novelty, but to understand roots.
Not to master tools, but to become worthy of building them.</p>

<p>Let others chase the ephemeral.
We are here to build what endures.</p>

</div>
</details>

---

### Douglas Hofstadter; Gödel, Escher, Bach {#geb}
If you're going to read only one book from this list, make it this one.

It’s not a book about software development per se.
The central question it explores is:
**how can inanimate systems become animate?**
Or put differently: how can self-awareness emerge from formal, mechanical rules?

The thesis is deeply relevant to the way we think as programmers.
Formal systems are the atoms of computer science.
Every programming language is a formal language; every computer implements a formal system.
And yet, Hofstadter shows how these rigid systems can give rise to self-reference, recursion, and ultimately, meaning.

This book will stretch your intuition.
It uses computers not just as tools, but as metaphors.
It draws analogies between symbols in logic, notes in music, and patterns in biology.
It connects Gödel’s incompleteness theorems to Bach’s fugues and Escher’s paradoxes, all in the service of understanding what it means for something to *think*.

To understand computing deeply is not to build apps or automate workflows.
It is to see the world differently.
*Gödel, Escher, Bach* offers a lens; one that most people will refuse to wear, but that will permanently rewire how you think if you do.
